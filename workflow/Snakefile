# Snakemake workflow for phased mapping with pairtools
# Juan Caballero
# (C) 2024

import yaml
from pathlib import Path

# Set variables
wildcard_constraints: sample=r".+\d+"
SAMPLES, = glob_wildcards(
    Path(config['fastq_dir']) / '{sample}_R1.fastq.gz'
)
REFERENCES = config['bwa_parameters'].keys()
PHASETYPES = [
    config['hap_1'],
    config['hap_2'],
    'unphased',
    'trans'
]

PHASEFILTER = [
    '(phase1=="0") and (phase2=="0")',
    '(phase1=="1") and (phase2=="1")',
    '(phase1==".") or (phase2==".")',
    '(phase1!=phase2) and (phase1!=".") and (phase2!=".") and (phase1!="!") and (phase2!="!")'
]
PHASEDIC = dict(map(lambda i,j : (i,j) , PHASETYPES, PHASEFILTER))

# Define function that returns pair files (phased or unphased), based on the reference.
def ret_pair(wildcards):
    if 'diploid' in wildcards.ref:
        # Phased setting
        return f"04_pairing/{wildcards.sample}_{wildcards.ref}_phased.pairs.gz"
    else:
        return f"04_pairing/{wildcards.sample}_{wildcards.ref}.pairs.gz"

# before running the process
onstart:
    print("\n==== Variant calling pipeline starts ====")
    print("Configuration:")
    print(config)
    print("=" * 80)
    print()

# main workflow
rule all:
    input:
        "07_multiqc/multiqc_report.html"

rule fastp:
    input:
        fq1 = config['fastq_dir'] + "/{sample}_R1.fastq.gz",
        fq2 = config['fastq_dir'] + "/{sample}_R2.fastq.gz"
    output:
        trim_fq1 = "01_preprocessing/{sample}_R1.fastq.gz",
        trim_fq2 = "01_preprocessing/{sample}_R2.fastq.gz",
        html_rep = "01_preprocessing/{sample}_report.html",
        json_rep = "01_preprocessing/{sample}_report.json"
    threads: 10
    shell:
        """
        fastp \
            -w {threads} \
            -i {input.fq1} \
            -I {input.fq2} \
            -o {output.trim_fq1} \
            -O {output.trim_fq2} \
            -h {output.html_rep} \
            -j {output.json_rep}
        """

rule diploid_genome:
    input:
        genome = config["genome"],
        vcf = config["variants"]
    output:
        genome = "02_bwa_index/diploid_genome.fa.gz"
    threads: 4
    params:
        hap1 = config["hap_1"],
        hap2 = config["hap_2"]
    shell:
        """
        bcftools consensus \
            --fasta-ref {input.genome} \
            --haplotype 1 {input.vcf} \
            --sample {params.hap1} \
            | sed -E 's/(>[^[:space:]]+).*/\\1_{params.hap1}/g' \
            | bgzip -c > genome_{params.hap1}.fa.gz

        bcftools consensus \
            --fasta-ref {input.genome} \
            --haplotype 1 {input.vcf} \
            --sample {params.hap2} \
            | sed -E 's/(>[^[:space:]]+).*/\\1_{params.hap2}/g' \
            | bgzip -c > genome_{params.hap2}.fa.gz

        cat genome_{params.hap1}.fa.gz genome_{params.hap2}.fa.gz \
            > {output.genome}

        rm genome_{params.hap1}.fa.gz genome_{params.hap2}.fa.gz
        """

rule bwa_index_diploid_genome:
    input:
        genome = "02_bwa_index/diploid_genome.fa.gz"
    output:
        index = "02_bwa_index/diploid_genome.fa.gz.bwt"
    threads: 2
    resources:
        mem_mb = 50000
    shell:
        """
        bwa index {input.genome}
        """

rule bwa_index:
    input:
        fna = Path(config['ngenome']).resolve()
    output:
        index = "02_bwa_index/nmask_genome.fa.gz.bwt"
    threads: 2
    resources:
        mem_mb = 50000
    shell:
        """
        ln -s {input.fna} 02_bwa_index/nmask_genome.fa.gz
        bwa index 02_bwa_index/nmask_genome.fa.gz
        """

rule chr_sizes:
    input:
        bwaix = "02_bwa_index/{ref}.fa.gz.bwt"
    output:
        chromsize = "02_bwa_index/{ref}.chromsizes"
    params:
        fnagz = lambda wildcards, input: Path(input.bwaix).with_suffix('')
    threads: 1
    shell:
        """
        samtools faidx {params.fnagz}
        cut -f1,2 {params.fnagz}.fai > {output.chromsize}
        """

rule bwa_mapping:
    input:
        fq1 = "01_preprocessing/{sample}_R1.fastq.gz",
        fq2 = "01_preprocessing/{sample}_R2.fastq.gz",
        ix = "02_bwa_index/{ref}.fa.gz.bwt"
    output:
        bam = "03_mapping/{sample}.{ref}.bam"
    threads: 30
    params:
      bwathreads = 20,
      mapparams = lambda wildcards: config['bwa_parameters'][wildcards.ref],
      fna = lambda wildcards, input: Path(input.ix).with_suffix('')
    resources:
      mem_mb = 3000
    shell:
        """
        bwa mem \
            {params.mapparams} \
            -t {params.bwathreads} \
            {params.fna} \
            {input.fq1} \
            {input.fq2} \
        | samtools view -@ 8 -b \
        > {output.bam}
        """

rule pairtools_parse:
    input:
        bam = "03_mapping/{sample}.{ref}.bam",
        chr_sizes = "02_bwa_index/{ref}.chromsizes"
    output:
        pairs = "04_pairing/{sample}_{ref}.pairs.gz"
    params:
        minmapq = 40,
        cols = lambda wildcards: '--add-columns XB,AS,XS' if 'diploid' in wildcards.ref else ''
    threads: 12
    shell:
        """
        pairtools parse \
            --min-mapq {params.minmapq} \
            {params.cols} \
            --drop-sam \
            --walks-policy 5unique \
            -c {input.chr_sizes} \
            {input.bam} \
            -o {output.pairs}
        """

rule pairtools_phase:
    input:
        pairs = "04_pairing/{sample}_diploid_genome.pairs.gz"
    output:
        pairs = "04_pairing/{sample}_diploid_genome_phased.pairs.gz"
    params:
        hap1 = config["hap_1"],
        hap2 = config["hap_2"]
    threads: 12
    shell:
        """
        pairtools phase \
            --phase-suffixes _{params.hap1} _{params.hap2} \
            --tag-mode XB \
            --clean-output \
            {input.pairs} -o {output.pairs}
        """

rule pairtools_sort:
    input:
        ret_pair
    output:
        pairs = "04_pairing/{sample}_{ref}.pairs.sorted.gz"
    threads: 20
    shell:
        """
        pairtools sort \
            {input} \
            -o {output.pairs} \
            --memory 20G
        """

rule pairtools_dedup:
    input:
        pairs = "04_pairing/{sample}_{ref}.pairs.sorted.gz"
    output:
        pairs = "04_pairing/{sample}_{ref}.pairs.dedup.gz",
        stats = "04_pairing/{sample}_{ref}.pairs.dedup.stats"
    params:
        extra_cols = lambda wildcards: '--extra-col-pair phase1 phase2'  if 'diploid' in wildcards.ref else ''
    threads: 12
    shell:
        """
        pairtools dedup \
            --mark-dups \
            {params.extra_cols} \
            --output-dups - \
            --output-unmapped - \
            --output-stats {output.stats} \
            -o {output.pairs} \
            {input.pairs}
        """

rule pairtools_filter_phased:
    input:
        pairs = "04_pairing/{sample}_diploid_genome.pairs.dedup.gz"
    output:
        stats = "05_phase_stats/{sample}_diploid_genome_{phasetype}.pairs.stats",
        pairs = "05_phase_stats/{sample}_diploid_genome_{phasetype}.pairs.gz"
    params:
        filterparam = lambda wildcards: PHASEDIC[wildcards.phasetype]
    resources:
        mem_mb = 1000
    threads: 12
    shell:
        """
        pairtools select \
            '{params.filterparam}' \
            {input.pairs} \
            -o {output.pairs}
        pairtools stats {output.pairs} -o {output.stats}
        """


rule multiqc:
    input:
        stats = expand(
            "04_pairing/{sample}_{ref}.pairs.dedup.stats",
            sample=SAMPLES,
            ref=REFERENCES
        ),
        phasedstats = expand(
            "05_phase_stats/{sample}_diploid_genome_{phasetype}.pairs.stats",
            sample=SAMPLES,
            phasetype = PHASEDIC.keys()
        )
    output:
        html = "07_multiqc/multiqc_report.html"
    params:
        odir = "07_multiqc"
    threads: 1
    shell:
        """
        multiqc \
            --module pairtools \
            -o {params.odir} \
            .
        """

onsuccess:
    print("\n==== Workflow finished successfully! ====\n")
